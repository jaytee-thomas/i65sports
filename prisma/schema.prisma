generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String     @id @default(cuid())
  email     String     @unique
  username  String     @unique
  bio       String?
  avatarUrl String?
  role      Role       @default(USER)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt @default(now())
  clerkId   String?    @unique
  comments  Comment[]
  hotTakes  HotTake[]
  reactions Reaction[]
  
  // Follow relationships
  following Follow[] @relation("UserFollows")
  followers Follow[] @relation("UserFollowers")
  
  // Notification relationships
  notifications       Notification[] @relation("UserNotifications")
  triggeredNotifications Notification[] @relation("ActorNotifications")
  
  // Check-in relationships
  checkIns     CheckIn[]
  
  // Messaging relationships
  conversationParticipants ConversationParticipant[]
  sentMessages             Message[] @relation("SentMessages")
  messageReadReceipts      MessageReadReceipt[]
}

model HotTake {
  id        String     @id @default(cuid())
  authorId  String
  kind      TakeKind   @default(VIDEO)
  title     String?
  videoUrl  String?
  audioUrl  String?
  textBody  String?
  duration  Int?
  sport     String?
  league    String?
  tags      String[]
  createdAt DateTime   @default(now())
  status    TakeStatus @default(PUBLISHED)
  
  // VENUE FEATURES (merged from FanReel)
  recordedAtVenue Boolean  @default(false)
  gameId          String?
  venueLat        Float?
  venueLng        Float?
  venueName       String?
  shotAt          DateTime? // When recorded (useful for sorting venue takes)
  
  // Video metadata (merged from FanReel)
  thumbUrl String?
  width    Int?
  height   Int?
  
  // Relations
  comments  Comment[]
  author    User       @relation(fields: [authorId], references: [id])
  game      Game?      @relation(fields: [gameId], references: [id])
  reactions Reaction[]
  notifications Notification[]
  sharedInMessages Message[]
  
  // Indexes for performance
  @@index([createdAt])
  @@index([recordedAtVenue, createdAt])
  @@index([gameId, shotAt])
  @@index([league, createdAt])
}

model Reaction {
  id        String   @id @default(cuid())
  takeId    String
  userId    String
  emoji     String
  createdAt DateTime @default(now())
  take      HotTake  @relation(fields: [takeId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id])

  @@unique([takeId, userId, emoji])
}

model Comment {
  id        String   @id @default(cuid())
  authorId  String
  takeId    String
  body      String
  createdAt DateTime @default(now())
  author    User     @relation(fields: [authorId], references: [id])
  take      HotTake  @relation(fields: [takeId], references: [id], onDelete: Cascade)
  
  @@index([takeId, createdAt])
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String   // User who is following
  followingId String   // User being followed
  createdAt   DateTime @default(now())
  follower  User @relation("UserFollows", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model Game {
  id        String    @id @default(cuid())
  league    String
  homeTeam  String
  awayTeam  String
  venue     String?
  startTime DateTime
  seasonKey String?
  createdAt DateTime  @default(now())
  takes     HotTake[] // Changed from 'reels' to 'takes'

  @@index([league, startTime])
  @@index([homeTeam, awayTeam, startTime])
}

model Venue {
  id        String   @id @default(cuid())
  name      String
  city      String
  state     String
  latitude  Float
  longitude Float
  capacity  Int?
  sport     String?
  team      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, city])
  @@index([latitude, longitude])
  checkIns     CheckIn[]
  @@map("venues")
}

enum Role {
  USER
  COLUMNIST
  EDITOR
  ADMIN
}

enum TakeKind {
  VIDEO
  AUDIO
  TEXT
}

enum TakeStatus {
  PUBLISHED
  FLAGGED
  REMOVED
}

model Notification {
  id          String   @id @default(cuid())
  userId      String   // User who receives the notification
  actorId     String   // User who triggered the notification
  type        NotificationType
  hotTakeId   String?  // Related Hot Take (for likes, comments)
  commentId   String?  // Related Comment (for comment notifications)
  message     String
  read        Boolean  @default(false)
  createdAt   DateTime @default(now())
  
  user        User     @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  actor       User     @relation("ActorNotifications", fields: [actorId], references: [id], onDelete: Cascade)
  hotTake     HotTake? @relation(fields: [hotTakeId], references: [id], onDelete: Cascade)
  
  @@index([userId, createdAt])
  @@index([userId, read])
}

enum NotificationType {
  LIKE
  COMMENT
  FOLLOW
  MENTION
}

model CheckIn {
  id           String    @id @default(cuid())
  userId       String
  venueId      String
  checkedInAt  DateTime  @default(now())
  checkedOutAt DateTime?
  
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  venue Venue @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@index([venueId, checkedInAt])
  @@index([userId, checkedInAt])
  @@map("check_ins")
}

model Conversation {
  id          String   @id @default(cuid())
  type        ConversationType @default(DIRECT)
  name        String?  // For group chats
  imageUrl    String?  // For group chats
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  participants ConversationParticipant[]
  messages     Message[]
  
  @@map("conversations")
}

enum ConversationType {
  DIRECT
  GROUP
}

model ConversationParticipant {
  id             String   @id @default(cuid())
  conversationId String
  userId         String
  joinedAt       DateTime @default(now())
  lastReadAt     DateTime?
  
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([conversationId, userId])
  @@index([userId])
  @@map("conversation_participants")
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  senderId       String
  content        String
  type           MessageType @default(TEXT)
  sharedTakeId   String?  // For sharing Hot Takes
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  sharedTake   HotTake?     @relation(fields: [sharedTakeId], references: [id], onDelete: SetNull)
  readReceipts MessageReadReceipt[]
  
  @@index([conversationId, createdAt])
  @@index([senderId])
  @@map("messages")
}

enum MessageType {
  TEXT
  HOTTAKE
  SYSTEM
}

model MessageReadReceipt {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())
  
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, userId])
  @@index([userId])
  @@map("message_read_receipts")
}

// REMOVED: Article, FanReel, Reply, RecordingDraft models
// REMOVED: ReplyKind, ReelStatus, RecordingStatus enums
